#!/usr/bin/env eco


local mqtt = require 'eco.mqtt'
local time = require 'eco.time'
-- adding to path

package.path = package.path ..";/usr/lib/lua/?.lua"
local json = require "dkjson"
local brf = require "brfUtils"


local clientConnected = false


--read the config file
local config = brf.Load_config("/etc/cRelayMqttWrapperService.json")

local function verbose(level)	
	return level<= config.verbose 
end



local relayPath = ""
if config.Simulated==1 then
	--relayPath = "/usr/bin/cRelaySimulator.sh "
	relayPath = brf.GetFullFilePathFromOpk('cRelayMqttWrapperService','cRelaySimulator.sh')
else	
	relayPath = "/usr/bin/crelay "
end

local function SetReylay(payload)
	local number = payload:match("%d+")
	local cmd = payload:match("on") or payload:match("off")
	if cmd then
		local handle = io.popen("sh ".. relayPath .. " " .. number .. " " .. cmd )		
		print (relayPath .. number .. " " .. cmd )
	end
end

local function readnPublishRelayStates(client,RelayNum)		
	local shCmd=("sh ".. relayPath.. " -i")			
	local handle = io.popen(shCmd)			
	local result = handle:read("*a")
	handle:close()			
	if verbose(9) then print (result) end
	-- Parse the output into a Lua table
	
	local relays = brf.MqttHeader()
	local indentlevel = 1 	
	local idx = 0	
	
	--relays = relays .. brf.Indent(indentlevel) .. "{\n"
	--indentlevel = indentlevel +1	
	for line in result:gmatch("[^\r\n]+") do		
		local relay,state = line:match("(Relay%s%d+):%s*(%a+)")
		if relay and state then
			state=string.upper(state)
			if idx ~= 0 then			
			relays = relays ..",\n"
			end
			local RelayNumber = string.match(relay, "%d+$")
			local TasmotaRelayPub='stat'..config.Topic_String .."/POWER" .. RelayNumber
			client:publish(TasmotaRelayPub, state, mqtt.QOS0)
			
			relays = relays .. brf.Indent(indentlevel) .. '"'.. relay .. '":"'..state..'"'						
			idx=idx+1
		end		
	end	
	relays = relays .. brf.Indent(indentlevel) .."\n"
	for idx = indentlevel,1,-1 do	
		indentlevel = indentlevel -1		
		relays = relays .. brf.Indent(indentlevel) .."}\n"
	end
		
	if verbose(2) then print (relays) end
	
	-- Convert to JSON
	--local result = json.encode({Relays = relays}, {indent = true})
	local payload = relays
	local publishPath ='stat'..config.Topic_String 
	client:publish(publishPath, payload, mqtt.QOS0)
	if verbose(2) then 
		print ('Published:\n'.. payload)	
		print ('To '.. publishPath ..'\n')
	end		

	
	--print(result)

end
--
-- Create MQTT client
local client = mqtt.new({
    ipaddr = config.ipaddr,      -- Replace with your broker IP
    port = config.port,               -- Or 8883 for TLS
	username = config.username,
	password = config.password,
    clean_session = true
})


-- Optional: set keepalive interval
client:set('keepalive', 10.0)


-- Define MQTT event handlers

client:on({	
	conack = function(ack, client)
		--This is what we do when first connected
		if verbose(1) then print('Connected to broker:', ack.rc) end
		if ack.rc == 0 then
			clientConnected=true
		end
		--readnPublishTemperatures(client)	
		--define what we want to subscribe to		
		client:subscribe('cmnd'.. config.Topic_String, mqtt.QOS0)	
		if verbose(1) then print ("subscribed to: "..'cmnd'.. config.Topic_String) end
	end,
	
	publish  = function(pkt, client)
	--this is what we do, when we recieve a meassage
		
		if verbose(2) then 
			print('Received message on topic:', pkt.topic) 
			print('Payload:', pkt.payload) 
		end
		SetReylay(pkt.payload)	
		--return read and publish sensor		
		readnPublishRelayStates(client,number)				
		
		
	end,

	error = function(err)
		print('MQTT error:', err)
	end

})



--start the mqtt client, restart if it chrashes
eco.run(function(name)		
	if verbose(1) then print("Starting task eco1") end
	while true do 
		client:run()
		clientConnected=false
		time.sleep(5)
	end
end,'cRelaymqttWrap1')

--resend every polltime sec
eco.run(function(name)
	time.sleep(5)
	if verbose(1) then print("Starting task eco2") end
	while true do 		
		readnPublishRelayStates(client)				
		time.sleep(config.PollTime)
	end
end,'cRelaymqttWrap2')






--cmnd/TOPIC/POWER{id}	to middleware	Controls the specified relay (ON/OFF/TOGGLE)
--stat/TOPIC/POWER{id}	from middleware	Returns the state of the relay (ON/OFF)
--tele/TOPIC/LWT	from middleware	Returns the status of the middleware (Online/Offline)