#!/usr/bin/env eco


local mqtt = require 'eco.mqtt'
local time = require 'eco.time'
-- adding to path

package.path = package.path ..";/usr/lib/lua/?.lua"
local json = require "dkjson"
local brfUtils = require "brfUtils"

-- Function to read file contents
local function read_file(path)
    local file = io.open(path, "r")
    if not file then
        error("Could not open file: " .. path)
    end
    local content = file:read("*a")	
    file:close()	
    return content
end

-- Load and parse JSON config
local function load_config(path)	
    local content = read_file(path)		
    local config, pos, err = json.decode(content, 1, nil)
	if err then
        error("JSON decode error: " .. err)
    end
    return config
end	


--read the config file
local config = load_config("/etc/cRelayMqttWrapperService.json")

-- Create MQTT client
local client = mqtt.new({
    ipaddr = config.ipaddr,      -- Replace with your broker IP
    port = config.port,               -- Or 8883 for TLS
	username = config.username,
	password = config.password,
    clean_session = true
})


local relayPath = ""
if config.Simulated==1 then
	relayPath = "/usr/bin/cRelaySimulator.sh "
else	
	relayPath = "/usr/bin/crelay "
end


-- -- Create MQTT client
-- local client = mqtt.new({
--     ipaddr = '192.168.40.136',      -- Replace with your broker IP
--     port = 1883,               -- Or 8883 for TLS
-- 	username = 'Thing01',
-- 	password = 'nulle',
--     clean_session = true
-- })

local function readnPublishRelayStates(client,RelayNum)		
	print ("sh ".. relayPath.. "-i")			
	local handle = io.popen("sh ".. relayPath.. "-i")			
	local result = handle:read("*a")
	handle:close()			
	--print (result)		
	-- Parse the output into a Lua table
	
	local relays = brfUtils.MqttHeader()
	local indentlevel = 1 	
	local idx = 0	
	
	relays = relays .. brfUtils.Indent(indentlevel) .. "{\n"
	indentlevel = indentlevel +1	
	for line in result:gmatch("[^\r\n]+") do		
		local relay,state = line:match("(Relay%s%d+):%s*(%a+)")
		if relay and state then
			if idx ~= 0 then			
			relays = relays ..",\n"
			end
			--print (relays)
			--print ('"' .. relay .. '"')
			--print ('"' .. state .. '"')
			--relays[relay] = state	
			relays = relays .. brfUtils.Indent(indentlevel) .. '"'.. relay .. '":"'..state..'"'						
			idx=idx+1
		end		
	end	
	relays = relays .. brfUtils.Indent(indentlevel) .."\n"
	for idx = indentlevel,1,-1 do	
		indentlevel = indentlevel -1		
		relays = relays .. brfUtils.Indent(indentlevel) .."}\n"
	end
		
	print (relays)
	
	-- Convert to JSON
	--local result = json.encode({Relays = relays}, {indent = true})
	local payload = relays
	client:publish('stat'..config.Topic_String , payload, mqtt.QOS0)
	print('Published:\n'.. payload)			

	
	--print(result)

end

-- Optional: set keepalive interval
client:set('keepalive', 10.0)
--


-- Define MQTT event handlers


client:on({	
	conack = function(ack, client)
		print('Connected to broker:', ack.rc)		
		readnPublishRelayStates(client,RelayNum)								
		client:subscribe('cmnd'..config.Topic_String, mqtt.QOS0)
	end,
	
	publish = function(pkt, client)
        print('Received message on topic:', pkt.topic)
	
		-- Extract number and command using pattern matching
		print('Payload:', pkt.payload)
		local number = pkt.payload:match("%d+")
		local cmd = pkt.payload:match("on") or pkt.payload:match("off")
		if cmd then
			local handle = io.popen("sh ".. relayPath .. number .. " " .. cmd )		
			print (relayPath .. number .. " " .. cmd )
	    end
		readnPublishRelayStates(client,number)				
	end,
--
	error = function(err)
		print('MQTT error:', err)
	end
})



-- Run the client loop
while true do
	
    client:run()
    time.sleep(5)
end

--cmnd/TOPIC/POWER{id}	to middleware	Controls the specified relay (ON/OFF/TOGGLE)
--stat/TOPIC/POWER{id}	from middleware	Returns the state of the relay (ON/OFF)
--tele/TOPIC/LWT	from middleware	Returns the status of the middleware (Online/Offline)