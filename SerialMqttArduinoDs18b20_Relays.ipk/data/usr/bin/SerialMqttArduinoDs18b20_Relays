#!/usr/bin/env eco

local mqtt = require 'eco.mqtt'
local time = require 'eco.time'
local termios = require 'eco.termios'
local file = require 'eco.file'
local bufio = require 'eco.bufio'


-- adding to path
-- adding to path
package.path = package.path ..";/usr/lib/lua/?.lua"
local brf =  require 'brfUtils'


--Read config data from config file
local config = brf.Load_config("/etc/SerialMqttArduinoDs18b20_Relays.json")


--INTERNAL "GLOBAL" VARAIABLES SECTION



local serialPortPath=""
local pts1 
local pts2
local clientConnected=false 

--\INTERNAL "GLOBAL" VARAIABLES SECTION

--functions section

function verbose(level)	
	return level<= config.verbose 
end

function setTermiosSpeedFromVal(speed)
	speed = speed or 9600
	local baud_key = "B" .. tostring(speed)
	local baud_const = termios[baud_key]
	if not baud_const then
		error("Unsupported baud rate: " .. tostring(speed))
	end
	return baud_const
	
end
	


function SerialPort(PortPath)		
		if verbose(5) then print("Opening serial port: "..PortPath ) end
		local f = file.open(PortPath)  -- open the selected return the raw file descriptor		
		if not f then
			print ("Serial port : "..PortPath .." not found" )			
		else
			local attr, err = termios.tcgetattr(f) --get the settings from the serial port
			local nattr = attr:clone() --make a copy of the settings 
			nattr:clr_flag('l', termios.ECHO)  -- Disable echo
			nattr:set_speed(setTermiosSpeedFromVal(config.Serial.baudRate))  -- Set baud rate
			--Set the new connection data
			termios.tcsetattr(f, termios.TCSANOW, nattr)		
			if verbose(2) then print ("Serial port : "..PortPath .." open" ) end
		end
		return f

end

function readnPublishTemperatures(client,Sensornum)
	Sensornum = tonumber(Sensornum) or -1 -- -1 = all
	local command = "S" .. Sensornum .. "\n"
	
	local fd= SerialPort(serialPortPath)
	if verbose(3) then
		print("File descriptor: ",fd)	
		print("Command to send : "..command)
	end
	local ok, eco = file.writefile(serialPortPath, command)
	--Send a request for data
	if not ok then
		print("Failed to send command: "..command.. " Result: " , err) 
	else
		if verbose(2) then
			print("Sent command: "..command.. " Result: " , err)
		end
	end
	
	local b = bufio.new(fd)
	-- Read a line (ends with \n)
	--local line, err = b:readline()
	--local line, err = b:read('l')
	local timeout = 2
	local result = brf.MqttHeader()
	local LineCount=0
	while true do
	--local line, err = b:read('L')		
		local line, err = b:read('L',timeout)
		if line then						
			result = result ..brf.Indent(2) .. line:gsub("\n", ",\n")
			LineCount=LineCount+1
				
			 if verbose(11) then print("Received line:", line) end
		elseif err == "timeout" then
			if verbose(5) then  print("All data read") end 
			break  -- no more data within timeout
		else
			print("Read error:", err)
			break
		end
	end
	--remove the last comma
	result= result:gsub(",%s*$", "\n}")
	
	if verbose(5) then print (result) end 
	if verbose(2) then print("Closing serial port: "..serialPortPath ) end
	file.close(fd)
	
	client:publish('tele'..config.Topic_String .."/SENSOR" , result, mqtt.QOS0)
	if verbose(2) then print('Published:\n'.. result) end			
end


function Set_n_GetRelays(client,RelayNumber,cmd)
	RelayNumber=tonumber(RelayNumber) or -1
	cmd = cmd or "-1"
	if RelayNumber==-1 then
		for idx =1,config.NrOfRelays, 1 do
			if verbose(5) then 
				print('Recursive idx: ',idx) 
				print('Recursive cmd: ',cmd) 
			end	
			Set_n_GetRelay(client,idx,cmd)
		end
		if verbose(2) then print('Recursive done') end					
	else
		if RelayNumber>0 and RelayNumber<=config.NrOfRelays then
			Set_n_GetRelay(client,RelayNumber,cmd)
		end
	end
end
	
function Set_n_GetRelay(client,RelayNumber,cmd)
	local command = "R" .. RelayNumber .."_".. cmd .."\n"	
	local fd= SerialPort(serialPortPath)
	if verbose(7) then
		print("File descriptor: ",fd)					
		print('RelayNumber: ',RelayNumber) 
		print('command: ',command) 
		print()
	end	
	local ok, eco = file.writefile(serialPortPath, command)
	--The data to the serial port
	if not ok then
		print("Failed to send command: "..command.. " Result: " , err) 
	else
		if verbose(2) then
			print("Sent command: "..command.. " Result: " , err)
		end
	end
	
	local b = bufio.new(fd)
	-- Read a line (ends with \n)
	--local line, err = b:readline()
	--local line, err = b:read('l')
	local timeout = 2
	local result =""
	local LineCount=0

	while true do
	--local line, err = b:read('L')		
		local line, err = b:read('L',timeout)		
		if line then						
			result = result ..brf.Indent(2) .. line:gsub("\n", ",\n")
			LineCount=LineCount+1
				
			 if verbose(2) then print("Received line:", line) end
		elseif err == "timeout" then
			if verbose(2) then  print("All data read") end 
			break  -- no more data within timeout
		else
			print("Read error:", err)
			break
		end
	end
	
	if verbose(2) then print (result) end 
	print ("result: ".. result)
	local key, value = result:match('"([^"]+)"%s*:%s*"([^"]+)"')
	if key and value then
		local TopicToWrite='stat'.. config.Topic_String .."/".. key
		if verbose(1) then 
			print("TopicToWrite: ".. TopicToWrite)   --> POWER
			print("value: "..value) --> "OFF"
		end
		
		if verbose(5) then print("Closing serial port: "..serialPortPath ) end		
		client:publish(TopicToWrite, value, mqtt.QOS0)
		if key=="1" then
			--Write relay 1 to POWER as well as POWER1
			local TopicToWrite='stat'.. config.Topic_String .."/".. POWER
			client:publish(TopicToWrite, value, mqtt.QOS0)
		end
		if verbose(2) then print('Published:\n'.. result) end			
		
	end
	file.close(fd)
		
--]]
end

--\functions section


--startup the simulation if wanted
if config.sim_data.Simulated==1 then
	if verbose(1) then print("Start the simulation") end	
	--Use socat for the serial simulation, remember the settings and record the pid, so socat can be stopped with the service
	local tmpfile = config.sim_data.tmpfile
	local pidfile = "/var/run/socat_output.SerialMqttArduinoDs18b20_Relays.pid"
	--socat -d -d pty,raw,echo=0,b9600 pty,raw,echo=0,b9600
	local serialPortDefinition="pty,raw,echo=0,b".. config.Serial.baudRate .. " "
	local cmd = "sh -c 'socat -d -d "..serialPortDefinition..serialPortDefinition .."> " .. tmpfile .. " 2>&1 & echo $! > " .. pidfile .. "'"
	if verbose(5) then
		print ("tmpfile: " .. tmpfile)
		print ("pidfile: " .. pidfile )
		print ("cmd: " .. cmd)
	end
	os.execute(cmd)
	-- Wait briefly for socat to start and write output
	time.sleep(5)
	-- Read PID
	local pidHandle = io.open(pidfile, "r")
	local pid = pidHandle:read("*l")
	pidHandle:close()
	if verbose(2) then print ("socat PID ".. pid) end
	-- Read the internal serial port paths from the temp file
	local handle = io.open(tmpfile, "r")
	local output = handle:read("*a")
	handle:close()

	-- Extract PTYs
	pts1 = output:match("PTY is (/dev/pts/%d+)")
	pts2 = output:match("PTY is /dev/pts/(%d+)", output:find(pts1) + 1)	

	-- Set the serialport for this program
	serialPortPath=pts1
	if verbose(1) then
		print("Created PTYs:")
		print("  PTY1: " .. (pts1 or "not found"))
		print("  PTY2: /dev/pts/" .. (pts2 or "not found"))
		print ("starting sim with /dev/pts".. pts2)
		
	end
	
	
	--local SimCmd = "/usr/bin/" .. "Serial2MqttArduinoDs18b20Simulator.lua "  .. pts2	
	local SimCmd =brf.GetFullFilePathFromOpk('SerialMqttArduinoDs18b20_Relays','Serial2MqttArduinoDs18b20Simulator') .. " ".. pts2
	
	if verbose(2) then
		print ("SimCmd: " .. SimCmd)
	end
	os.execute(SimCmd .." &")				
else 
	if verbose(1) then
		print("using serial port from ".. config.Serial_port)
	end
	pts1=0
	pts2=0
	serialPortPath=config.Serial_port	
	if verbose(1) then		
		print ("starting serialport ".. serialPortPath)		
	end


end	

-- Create MQTT client
local client = mqtt.new({
    ipaddr = config.ipaddr,      -- Replace with your broker IP
    port = config.port,               -- Or 8883 for TLS
	username = config.username,
	password = config.password,
    clean_session = true
})

-- Define MQTT event handlers

client:on({	
	conack = function(ack, client)
		--This is what we do when first connected
		if verbose(1) then print('Connected to broker:', ack.rc) end
		if ack.rc == 0 then
			clientConnected=true
		end
		Set_n_GetRelays(client)
		readnPublishTemperatures(client)				
		
		--define what we want to subscribe to		
		client:subscribe('cmnd'.. config.Topic_String.."/#", mqtt.QOS0)
		
		if verbose(1) then print ("subscribed to: "..'cmnd'.. config.Topic_String) end
	end,
	
	publish  = function(pkt, client)
	--this is what we do, when we recieve a meassage
		
		if verbose(2) then 
			print('Received message on topic:', pkt.topic) 
			print('Payload:', pkt.payload) 
		end
		local prefix, device, subject = pkt.topic:match("([^/]+)/([^/]+)/([^/]+)")
		local number = subject:match("%d+") or -1
		if prefix=="cmnd" then			
			local cmd = pkt.payload:match("on") or pkt.payload:match("off") or pkt.payload:match("1") or pkt.payload:match("0")
			if cmd == "1" then
				cmd ="on"
			elseif cmd == "0" then
				cmd ="off"
			end
			if verbose(7) then 
				print("Prefix:", prefix)
				print("Device:", device)
				print("subject:", subject)
				print("number:", number)
				print("cmd:", cmd)
			end
			Set_n_GetRelays(client,number,cmd)
		else
			--return read and publish sensors		
			readnPublishTemperatures(client,pkt.payload)
		end		
		--os.exit()
		--print("food")
	end,

	error = function(err)
		print('MQTT error:', err)
	end
})

--start the mqtt client, restart if it chrashes
eco.run(function(name)		
	if verbose(1) then print("Starting task eco1") end
	while true do 
		client:run()
		clientConnected=false
		time.sleep(5)
	end
end,'eco1')

--resend every polltime sec
eco.run(function(name)
	if verbose(1) then print("Starting task eco2") end
	while true do 		
		Set_n_GetRelays(client)
		readnPublishTemperatures(client)				
		time.sleep(config.PollTime)
	end
end,'eco2')



--[[
mqtt Topics 

cmnd/TOPIC/POWER{id}	to middleware	Controls the specified relay (ON/OFF/TOGGLE)
stat/TOPIC/POWER{id}	from middleware	Returns the state of the relay (ON/OFF)
tele/TOPIC/LWT	from middleware	Returns the status of the middleware (Online/Offline)

]]--