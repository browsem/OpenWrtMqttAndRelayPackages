#!/usr/bin/env eco

local mqtt = require 'eco.mqtt'
local time = require 'eco.time'


-- adding to path
-- adding to path
package.path = package.path ..";/usr/lib/lua/?.lua"
local brf =  require 'brfUtils'


--Read config data from config file
local config = brf.Load_config("/etc/TasmotaSimulator.json")


--INTERNAL "GLOBAL" VARAIABLES SECTION

local temp={} --temperature array
local sensorId={}
local relayPath = ""		
local startTime = os.time()


--\INTERNAL "GLOBAL" VARAIABLES SECTION

--functions section

local function verbose(level)	
	return level<= config.verbose 
end


local function randomFix(tempin)
	local NextToAddMin=0
	local NextToAddMax=5
	local NextToAdd=(math.random(NextToAddMin,NextToAddMax))
	local tempout
	if (NextToAdd % 2 == 0) then
		tempout=tempin+NextToAdd
	else
		tempout=tempin-NextToAdd
	end
	if tempout<config.temperature_Min then
		tempout=config.temperature_Min+NextToAdd
	end
	if tempout>config.temperature_Max then
		tempout=config.temperature_Max-NextToAdd
	end			
	return tempout
end				


local function readnPublishRelayStates(client,RelayNum)	

	
	local cmd = 'sh ' .. relayPath .. " -i"
	if verbose(5) then print('cmd: '.. cmd) end
	local handle = io.popen(cmd)			
	local result = handle:read("*a")
	handle:close()			
	if verbose(9) then print (result) end
	-- Parse the output into a Lua table
	
	local relays = brf.MqttHeader()
	local indentlevel = 1 	
	local idx = 0	
	
	--relays = relays .. brf.Indent(indentlevel) .. "{\n"
	--indentlevel = indentlevel +1	
	for line in result:gmatch("[^\r\n]+") do		
		local relay,state = line:match("(Relay%s%d+):%s*(%a+)")
		if relay and state then
			if idx ~= 0 then			
			relays = relays ..",\n"
			end
			--print (relays)
			--print ('"' .. relay .. '"')
			--print ('"' .. state .. '"')
			--relays[relay] = state	
			relays = relays .. brf.Indent(indentlevel) .. '"'.. relay .. '":"'..state..'"'						
			idx=idx+1
		end		
	end	
	relays = relays .. brf.Indent(indentlevel) .."\n"
	for idx = indentlevel,1,-1 do	
		indentlevel = indentlevel -1		
		relays = relays .. brf.Indent(indentlevel) .."}\n"
	end
		
	if verbose(2) then print (relays) end
	
	-- Convert to JSON
	--local result = json.encode({Relays = relays}, {indent = true})
	local payload = relays
	local publishPath ='stat'..config.Topic_String .."/POWER"
	client:publish(publishPath, payload, mqtt.QOS0)
	if verbose(2) then 
		print ('Published:\n'.. payload)	
		print ('To '.. publishPath ..'\n')
	end		

	
	--print(result)

end

local function Sensors(client)
	--read and send all sensors
	local result = brf.MqttHeader()
	local LineCount=0
	for idx=1,config.NumberOfSensors do
		--Make sure the array exists
		if not temp[idx] then
			temp[idx]=0
		end
		--Make the temperature go up slowly
		if os.time()< startTime+30 then
			if verbose(2) and idx==1 then
				print ("still Early")
			end		
			NextToAddMin=2
			NextToAddMax=math.floor(2*config.temperature_Min/(config.temperature_from_zero_to_min_time/config.PollTime))
			NextToAdd=(math.random(NextToAddMin,NextToAddMax))					
			temp[idx]=temp[idx]+NextToAdd
			
			if temp[idx]>config.temperature_Max then
				temp[idx]=randomFix(temp[idx])
			end
		else
			if verbose(2) and idx==1  then
				print ("late")
			end
			temp[idx]=randomFix(temp[idx])
		end
		if verbose(5) then
			print ("SensorTemp".. idx ..": " .. temp[idx])
			print ("sensorId".. idx ..": "..sensorId[idx])
		end
		
		local SensorData=('"DS18B20-'
			..idx.. 
			'": { "Id": "'
			.. sensorId[idx].. 
			'","Temperature": '
			..temp[idx] .. '},\n')
			
		if verbose(2) then print("SensorData: "..SensorData) end
		--add sensordata to result

		result= result .. brf.Indent(2) .. SensorData
		
	end
	--remove the last comma
	result= result:gsub(",%s*$", "\n}")	
	if verbose(5) then print (result) end 
	local publishPath ='stat'..config.Topic_String .."/SENSOR"
	client:publish(publishPath , result, mqtt.QOS0)
	if verbose(2) then 
		print('Published:\n'.. result) 
		print('To: '.. publishPath)
	end			
end

local function publishAll(client)
	readnPublishRelayStates(client)
	Sensors(client)	
end

local function SetReylay(payload)
	local number = payload:match("%d+")
	local cmd = payload:match("on") or payload:match("off")
	local shCmd="sh " ..relayPath  .. " ".. number .. " " .. cmd 
	if verbose(5) then
		print ("shCmd :" .. shCmd)
	end
	if cmd then
		local handle = io.popen(shCmd)		
	
	end
end

--\functions section



--Set the sensorID
sensorId=brf.DS18B20ID(config.NumberOfSensors,config.RandomSensorIdSeed)
--Get path to cRelay.sh
relayPath = brf.GetFullFilePathFromOpk('cRelayMqttWrapperService','cRelaySimulator.sh')
--add local file vars
relayPath = relayPath .." -n "..  config.NumberOfRelays .." -f ".. config.STATE_FILE 

-- Create MQTT client
local client = mqtt.new({
    ipaddr = config.ipaddr,      -- Replace with your broker IP
    port = config.port,               -- Or 8883 for TLS
	username = config.username,
	password = config.password,
    clean_session = true
})

-- Define MQTT event handlers

client:on({	
	conack = function(ack, client)
		--This is what we do when first connected
		if verbose(1) then print('Connected to broker:', ack.rc) end
		if ack.rc == 0 then
			clientConnected=true
		end
		--readnPublishTemperatures(client)	
		--define what we want to subscribe to		
		client:subscribe('cmnd'.. config.Topic_String.."/#", mqtt.QOS0)	
		if verbose(1) then print ("subscribed to: "..'cmnd'.. config.Topic_String.."/#") end
	end,
	
	publish  = function(pkt, client)
	--this is what we do, when we recieve a meassage
		
		if verbose(2) then 
			print('Received message on topic:', pkt.topic) 
			print('Payload:', pkt.payload)  
		end
		local prefix, device, subject = pkt.topic:match("([^/]+)/([^/]+)/([^/]+)")
		if verbose(2) then 
			print("Prefix:", prefix)
			print("Device:", device)
			print("subject:", subject)
		end		
		if subject=="POWER" then
			--were handling relays			
			local number = pkt.payload:match("%d+") or -1
			local cmd = pkt.payload:match("on") or pkt.payload:match("off")
			if cmd then
				SetReylay(pkt.payload)							
			end			
		end		
		--return read and publish sensors		
		publishAll(client)
		--os.exit()
		--print("food")
	end,

	error = function(err)
		print('MQTT error:', err)
	end
})


--start the mqtt client, restart if it chrashes
eco.run(function(name)		
	if verbose(1) then print("Starting task eco1") end
	--while true do 
		if config.Simulated then
			client:run()
			clientConnected=false
		else
			if verbose(1) then print("Not doing anything but sleeping") end
		end
		time.sleep(5)
	--end
end,'eco1')

--resend every polltime sec
eco.run(function(name)
	
	if verbose(1) then print("Starting task eco2") end
	while true do 
		if config.Simulated then	
			publishAll(client)	
		else
			if verbose(1) then print("Not doing anything but sleeping") end
		end
		time.sleep(config.PollTime)
	end
end,'eco2')



--[[
mqtt Topics 

cmnd/TOPIC/POWER{id}	to middleware	Controls the specified relay (ON/OFF/TOGGLE)
stat/TOPIC/POWER{id}	from middleware	Returns the state of the relay (ON/OFF)
tele/TOPIC/LWT	from middleware	Returns the status of the middleware (Online/Offline)

]]--