#!/usr/bin/env eco

local mqtt = require 'eco.mqtt'
local time = require 'eco.time'


-- adding to path
-- adding to path
package.path = package.path ..";/usr/lib/lua/?.lua"
local brf =  require 'brfUtils'


--Read config data from config file
local config = brf.Load_config("/etc/TasmotaSimulator.json")


--INTERNAL "GLOBAL" VARAIABLES SECTION

local temp={} --temperature array
local sensorId={}

local startTime = os.time()


--\INTERNAL "GLOBAL" VARAIABLES SECTION

--functions section

function verbose(level)	
	return level<= config.verbose 
end

--[[


function readnPublishTemperatures(client)
	print ("her")
	--open for read/write
	-- Write to serial, get all
	local SerialPortAsFile = io.open(serialPortPath, "w")
	local serialReq="all\n"
	if verbose(2) then 
		print("writing to :".. serialPortPath)
		print("SerialCmd: "..serialReq) 
	end
	SerialPortAsFile:write(serialReq)
	SerialPortAsFile:flush()
	SerialPortAsFile:close()
	
	local serial = io.open(serialPortPath, "r")			
	-- Read one line (blocks until newline is received)
	local done=false
	local LinesRead = 0
	
	StartTime = os.time()
	
	while not done do
		local line = serial:read("*line")
		if line then
			LinesRead=LinesRead+1
			if verbose(1) then 
				-- Print the received line
				print("Received:", line)
			end
		end
		if LinesRead>= config.NumberOfSensors then
			done=true
		end
		if StartTime+2<os.time() then
			done=true
		end	
	end
	print("done")
--handle serial answer

end


function setTermiosSpeedFromVal(speed)
	speed = speed or 9600
	local baud_key = "B" .. tostring(speed)
	local baud_const = termios[baud_key]
	if not baud_const then
		error("Unsupported baud rate: " .. tostring(speed))
	end
	return baud_const
	
end
	


function SerialPort(PortPath)

		if verbose(2) then print("Opening serial port: "..PortPath ) end
		local f = file.open(PortPath)  -- open the selected return the raw file descriptor		
		if not f then
			print ("Serial port : "..PortPath .." not found" )			
		else
			local attr, err = termios.tcgetattr(f) --get the settings from the serial port
			local nattr = attr:clone() --make a copy of the settings 
			nattr:clr_flag('l', termios.ECHO)  -- Disable echo
			nattr:set_speed(setTermiosSpeedFromVal(config.Serial.baudRate))  -- Set baud rate
			--Set the new connection data
			termios.tcsetattr(f, termios.TCSANOW, nattr)		
			if verbose(2) then print ("Serial port : "..PortPath .." open" ) end
		end
		return f

end

function readnPublishTemperatures(client,Sensornum)
	Sensornum = tonumber(Sensornum) or -1 -- -1 = all
	local command = Sensornum .. "\n"
	
	local fd= SerialPort(serialPortPath)
	if verbose(3) then
		print("File descriptor: ",fd)	
		print("Command to send : "..command)
	end
	local ok, eco = file.writefile(serialPortPath, command)
	--Send a request for data
	if not ok then
		print("Failed to send command: "..command.. " Result: " , err) 
	else
		if verbose(2) then
			print("Sent command: "..command.. " Result: " , err)
		end
	end
	
	local b = bufio.new(fd)
	-- Read a line (ends with \n)
	--local line, err = b:readline()
	--local line, err = b:read('l')
	local timeout = 2
	local result = brf.MqttHeader()
	local LineCount=0
	while true do
	--local line, err = b:read('L')		
		local line, err = b:read('L',timeout)
		if line then						
			result = result ..brf.Indent(2) .. line:gsub("\n", ",\n")
			LineCount=LineCount+1
				
			 if verbose(11) then print("Received line:", line) end
		elseif err == "timeout" then
			if verbose(5) then  print("All data read") end 
			break  -- no more data within timeout
		else
			print("Read error:", err)
			break
		end
	end
	--remove the last comma
	result= result:gsub(",%s*$", "\n}")
	
	if verbose(5) then print (result) end 
	if verbose(2) then print("Closing serial port: "..serialPortPath ) end
	file.close(fd)
	
	client:publish('stat'..config.Topic_String , result, mqtt.QOS0)
	if verbose(2) then print('Published:\n'.. result) end			
end

function ShapeAndSendData(StartSensor)
	local Output =""
	local nrOfSensors=0
	local NextToAddMin=0
	local NextToAddMax=0
	local NextToAdd=0
	
	if StartSensor then
		nrOfSensors=StartSensor
	else
		StartSensor=1
		nrOfSensors=config.NumberOfSensors
	end
	--for all simulated sensors
	
	
end

	
end	

--]]

function randomFix(tempin)
	local NextToAddMin=0
	local NextToAddMax=5
	local NextToAdd=(math.random(NextToAddMin,NextToAddMax))
	local tempout
	if (NextToAdd % 2 == 0) then
		tempout=tempin+NextToAdd
	else
		tempout=tempin-NextToAdd
	end
	if tempout<config.temperature_Min then
		tempout=config.temperature_Min+NextToAdd
	end
	if tempout>config.temperature_Max then
		tempout=config.temperature_Max-NextToAdd
	end			
	return tempout
end				



function Relays(client,number,cmd)
	number = tonumber(number) or -1 -- -1 = all 
	cmd = cmd or ""
	if verbose(1) then print('Set relay: ' .. number ..": ".. cmd) end
	
end

function Sensors(client)
	--read and send all sensors
	local result = brf.MqttHeader()
	local LineCount=0
	for idx=1,config.NumberOfSensors do
		--Make sure the array exists
		if not temp[idx] then
			temp[idx]=0
		end
		--Make the temperature go up slowly
		if os.time()< startTime+30 then
			if verbose(2) and idx==1 then
				print ("still Early")
			end		
			NextToAddMin=2
			NextToAddMax=math.floor(2*config.temperature_Min/(config.temperature_from_zero_to_min_time/config.PollTime))
			NextToAdd=(math.random(NextToAddMin,NextToAddMax))					
			temp[idx]=temp[idx]+NextToAdd
			
			if temp[idx]>config.temperature_Max then
				temp[idx]=randomFix(temp[idx])
			end
		else
			if verbose(2) and idx==1  then
				print ("late")
			end
			temp[idx]=randomFix(temp[idx])
		end
		if verbose(5) then
			print ("SensorTemp".. idx ..": " .. temp[idx])
			print ("sensorId".. idx ..": "..sensorId[idx])
		end
		
		local SensorData=('"DS18B20-'
			..idx.. 
			'": { "Id": "'
			.. sensorId[idx].. 
			'","Temperature": '
			..temp[idx] .. '},\n')
			
		if verbose(2) then print("SensorData: "..SensorData) end
		--add sensordata to result

		result= result .. brf.Indent(2) .. SensorData
		
	end
	--remove the last comma
	result= result:gsub(",%s*$", "\n}")	
	if verbose(5) then print (result) end 
	
	client:publish('stat'..config.Topic_String .."/SENSOR" , result, mqtt.QOS0)
	if verbose(2) then 
		print('Published:\n'.. result) 
		print('To: '.. 'stat'..config.Topic_String .."/SENSOR")
	end			
end


function publishAll(client)
	Relays(client)
	Sensors(client)
end

--\functions section



--Set the sensorID
sensorId=brf.DS18B20ID(config.NumberOfSensors,config.RandomSensorIdSeed)




-- Create MQTT client
local client = mqtt.new({
    ipaddr = config.ipaddr,      -- Replace with your broker IP
    port = config.port,               -- Or 8883 for TLS
	username = config.username,
	password = config.password,
    clean_session = true
})

-- Define MQTT event handlers

client:on({	
	conack = function(ack, client)
		--This is what we do when first connected
		if verbose(1) then print('Connected to broker:', ack.rc) end
		if ack.rc == 0 then
			clientConnected=true
		end
		--readnPublishTemperatures(client)	
		--define what we want to subscribe to		
		client:subscribe('cmnd'.. config.Topic_String.."/#", mqtt.QOS0)	
		if verbose(1) then print ("subscribed to: "..'cmnd'.. config.Topic_String.."/#") end
	end,
	
	publish  = function(pkt, client)
	--this is what we do, when we recieve a meassage
		
		if verbose(2) then 
			print('Received message on topic:', pkt.topic) 
			print('Payload:', pkt.payload)  
		end
		local prefix, device, subject = pkt.topic:match("([^/]+)/([^/]+)/([^/]+)")
		if verbose(2) then 
			print("Prefix:", prefix)
			print("Device:", device)
			print("subject:", subject)
		end		
		if subject=="POWER" then
			--were handling relays			
			local number = pkt.payload:match("%d+") or -1
			local cmd = pkt.payload:match("on") or pkt.payload:match("off")
			if cmd then
				Relays(client,number,cmd)				
			end			
		end		
		--return read and publish sensors		
		publishAll(client)
		--os.exit()
		--print("food")
	end,

	error = function(err)
		print('MQTT error:', err)
	end
})


--start the mqtt client, restart if it chrashes
eco.run(function(name)		
	if verbose(1) then print("Starting task eco1") end
	while true do 
		if config.Simulated then
			client:run()
			clientConnected=false
		else
			if verbose(1) then print("Not doing anything but sleeping") end
		end
		time.sleep(5)
	end
end,'eco1')

--resend every polltime sec
eco.run(function(name)
	
	if verbose(1) then print("Starting task eco2") end
	while true do 
		if config.Simulated then	
			publishAll(client)						
		else
			if verbose(1) then print("Not doing anything but sleeping") end
		end
		time.sleep(config.PollTime)
	end
end,'eco2')



--[[
mqtt Topics 

cmnd/TOPIC/POWER{id}	to middleware	Controls the specified relay (ON/OFF/TOGGLE)
stat/TOPIC/POWER{id}	from middleware	Returns the state of the relay (ON/OFF)
tele/TOPIC/LWT	from middleware	Returns the status of the middleware (Online/Offline)

]]--