#!/usr/bin/env eco

local mqtt = require 'eco.mqtt'
local time = require 'eco.time'
local termios = require("eco.termios")
local file = require("eco.file")

-- adding to path
-- adding to path
package.path = package.path ..";/usr/lib/lua/?.lua"
local brf =  require 'brfUtils'


--Read config data from config file
local config = brf.Load_config("/etc/Serial2MqttArduinoDs18b20.json")


--INTERNALT "GLOBAL" VARAIABLES SECTION

local serialPortPath=""
local pts1 
local pts2
local clientConnected=false 

--\INTERNALT "GLOBAL" VARAIABLES SECTION

--functions section

function verbose(level)	
	return level<= config.verbose 
end

function setSerial()
	--configure the serial port
	local SerSetCmd="stty -F ".. serialPortPath .. " "  .. config.Serial.baudRate .. " "  .. config.Serial.settings
	if verbose(2) then
		print (SerSetCmd)
	end
	os.execute(SerSetCmd)
end

function readnPublishTemperatures(client)
	print ("her")
	--open for read/write
	-- Write to serial, get all
	local SerialPortAsFile = io.open(serialPortPath, "w")
	local serialReq="all\n"
	if verbose(2) then print("SerialCmd: "..serialReq) end
	SerialPortAsFile:write(serialReq)
	SerialPortAsFile:flush()
	SerialPortAsFile:close()

	local serial = io.open(serialPortPath, "r")			
	-- Read one line (blocks until newline is received)
	local done=false
	local LinesRead = 0
	StartTime = os.time()
	
	while not done do
		local line = serial:read("*line")
		if line then
			LinesRead=LinesRead+1
			if verbose(1) then 
				-- Print the received line
				print("Received:", line)
			end
		end
		if LinesRead>= config.nr
		if StartTime+2<os.time() then
			done=true
		end	
	end
	print("done")
--handle serial answer

end

--\functions section


--startup the simulation if wanted
if config.sim_data.Simulated==1 then
	if verbose(1) then print("Start the simulation") end	
	--Use socat for the serial simulation, remember the settings and record the pid, so socat can be stopped with the service
	local tmpfile = config.sim_data.tmpfile
	local pidfile = "/var/run/socat_output.Serial2MqttArduinoDs18b20.pid"
	local serialPortDefinition="pty,raw,echo=0,b".. config.Serial.baudRate .. " "
	local cmd = "sh -c 'socat -d -d "..serialPortDefinition..serialPortDefinition .."> " .. tmpfile .. " 2>&1 & echo $! > " .. pidfile .. "'"
	if verbose(5) then
		print ("tmpfile: " .. tmpfile)
		print ("pidfile: " .. pidfile )
		print ("cmd: " .. cmd)
	end
	os.execute(cmd)
	-- Wait briefly for socat to start and write output
	time.sleep(5)
	-- Read PID
	local pidHandle = io.open(pidfile, "r")
	local pid = pidHandle:read("*l")
	pidHandle:close()
	if verbose(2) then print ("socat PID ".. pid) end
	-- Read the internal serial port paths from the temp file
	local handle = io.open(tmpfile, "r")
	local output = handle:read("*a")
	handle:close()

	-- Extract PTYs
	pts1 = output:match("PTY is (/dev/pts/%d+)")
	pts2 = output:match("PTY is /dev/pts/(%d+)", output:find(pts1) + 1)	

	-- Set the serialport for this program
	serialPortPath=pts1
	if verbose(1) then
		print("Created PTYs:")
		print("  PTY1: " .. (pts1 or "not found"))
		print("  PTY2: /dev/pts/" .. (pts2 or "not found"))
		print ("starting sim with /dev/pts".. pts2)
		
	end
	local SimCmd = brf.Script_path() .. "Serial2MqttArduinoDs18b20Simulator.lua "  .. pts2	
	if verbose(2) then
		print (SimCmd)
	end
	os.execute(SimCmd .."&")				
else 
	if verbose(1) then
		print("using serial port from ".. config.Serial_port)
	end
	pts1=0
	pts2=0
	serialPortPath=config.Serial_port	
	if verbose(1) then		
		print ("starting serialport ".. serialPortPath)		
	end
	setSerial()
	--configure the serial port
	local SerSetCmd="stty -F ".. serialPortPath .. " "  .. config.Serial.baudRate .. " "  .. config.Serial.settings
	if verbose(2) then
		print (SerSetCmd)
	end
	os.execute(SimCmd .."&")
	
end	



-- Create MQTT client
local client = mqtt.new({
    ipaddr = config.ipaddr,      -- Replace with your broker IP
    port = config.port,               -- Or 8883 for TLS
	username = config.username,
	password = config.password,
    clean_session = true
})

-- Define MQTT event handlers

client:on({	
	conack = function(ack, client)
		--This is what we do when first connected
		if verbose(1) then print('Connected to broker:', ack.rc) end
		if ack.rc == 0 then
			clientConnected=true
		end
		--readnPublishTemperatures(client)	
		--define what we want to subscribe to		
		client:subscribe('cmnd'.. config.Topic_String, mqtt.QOS0)	
		if verbose(1) then print ("subscribed to: "..'cmnd'.. config.Topic_String) end
	end,
	
	publish  = function(pkt, client)
	--this is what we do, when we recieve a meassage
		if verbose(1) then print('Received message on topic:', pkt.topic) end
		--return read and publish sensors
		readnPublishTemperatures(client)
		--print("food")
	end,

	error = function(err)
		print('MQTT error:', err)
	end
})

--start the mqtt client, restart if it chrashes
eco.run(function(name)		
	if verbose(1) then print("Starting task eco1") end
	while true do 
		client:run()
		clientConnected=false
		time.sleep(5)
	end
end,'eco1')

--resend every polltime sec
eco.run(function(name)
	if verbose(1) then print("Starting task eco2") end
	while true do 		
		readnPublishTemperatures(client)				
		time.sleep(config.PollTime)
	end
end,'eco2')



--[[





--Function to send temperatures to mqtt
local function readnPublishTemperatures(client,verbose)
	local sensors={}
	--Open the serial port	
	local serial = io.open(serialPortPath, "r")
	if not serial then
		error("Failed to open serial port")
	end
	
	--get ALL data from the port
	local data = serial:read("*line")  -- Reads until newline
	local StartTime=time.now()	
	local count=0
	local timeout=false
	while (data and not timeout) do
		
		if verbose then print("Received:", data) end 
		print("Received:", data)
			
		local numbers = {}
		--Get sensor number and value from the string
		for num in string.gmatch(data, "%d+") do
			table.insert(numbers, tonumber(num))
		end
	    brfUtils.AddToTableByIdx(sensors,numbers[1],numbers[2])
		
			--Add the sensor + value to sensors
			--table.insert(sensors, {
			--	id = numbers[1],
			--	value = numbers[2]
			--})
		data = serial:read("*line")  -- Reads until newline	
		count=brfUtils.TblCount(sensors)
		if count>=2 then
			if time.now()<StartTime+config.PollTime then
				timeout = true
			end
		end
	end

	--get a timestamp, to mimmic tasmotas way of doing things
	local handle = io.popen("date -Iseconds")
	local timestamp = handle:read("*a"):gsub("\n", "")
	handle:close()
	--verbose and print("timestamp: "..timestamp)
		

	local Output = brfUtils.MqttHeader()	
	
	for id, value in pairs(sensors) do
		indentlevel = 1 
		indent = string.rep("  ", indentlevel)
		Output = Output .. indent .. '"DS18B20-' .. id ..'": {\n'
		indentlevel = 2 
		indent = string.rep("  ", indentlevel)
		Output = Output .. indent ..'"Temperature": ' .. value .. '\n'		
		indentlevel = 1 
		indent = string.rep("  ", indentlevel)
		Output = Output .. indent .. '},\n'		
		if verbose then print ('"DS18B20-' .. id ..':  ' .. value ) end
	end
		Output = Output .. indent .. '"TempUnit": "C"\n'
		Output = Output ..'}'
		client:publish('stat'..config.Topic_String , Output, mqtt.QOS0)

	if verbose then  print('Published:',Output) end	
end









--[[
mqtt Topics 

cmnd/TOPIC/POWER{id}	to middleware	Controls the specified relay (ON/OFF/TOGGLE)
stat/TOPIC/POWER{id}	from middleware	Returns the state of the relay (ON/OFF)
tele/TOPIC/LWT	from middleware	Returns the status of the middleware (Online/Offline)

]]--